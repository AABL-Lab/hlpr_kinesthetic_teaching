"""
keyframe_bag_parser.py

Parses and reads .bag files containing keyframe recordings generated by demonstration.py

"""

import os
import rosbag
import roslib
import rospy

from hlpr_record_demonstration.playback_demonstration_action_server import PlaybackKFDemoAction

class ParseException(Exception):
    pass

class KeyframeBagParser():
    
    def __init__(self):
        self.bag = None

    def parse(self, file):
        """
        Parses the keyframes from a bag file
        Adapted from do_playback_keyframe_demo() in playback_demonstration_action_server.py
        """
        if not os.path.isfile(file):
            raise ParseException("File does not exist")

        with rosbag.Bag(file) as bag:
            self.bag = bag
            parsed = []

            all_topics = self.bag.get_type_and_topic_info().topics.keys()
            GRIPPER_TOPIC = "gripper/stat"
            gripper_topics = [x for x in all_topics if GRIPPER_TOPIC in x]

            for topic, msg, time in self.bag.read_messages():
                # Grabber and joint messages will be linked if they are within 100 ms of each other
                # More precision runs into problems described at https://stackoverflow.com/a/22155830
                time_key = round(time.to_time(), 1)

                data = [item for item in parsed if item["time"] == time_key]
                shouldAppend = False
                if len(data) > 0:
                    data = data[0]
                else:
                    data = dict(
                        time = time_key,
                        data = dict()
                    )    
                    shouldAppend = True

                if topic in gripper_topics:
                    # Gripper has different data
                    data["data"][topic] = dict(
                        position = msg.position,
                        requested_position = msg.requested_position
                    )
                else:
                    for i, name in enumerate(msg.name):
                        data["data"]["/{}/{}".format(topic, name)] = dict(
                            position = msg.position[i],
                            velocity = msg.velocity[i],
                            effort = msg.effort[i]
                        )

                if shouldAppend:
                    parsed.append(data)
            return parsed